// ---------------------------* Hash Sets *---------------------------


/*
# Hash Sets
# Overview
--- A Hash Set is a data structure based on Hash Tables that allows quick search, addition, and deletion of elements. It's typically used to verify the 
    presence of unique elements in a set. Hash Sets are particularly powerful for applications requiring constant time complexity for searches and operations, 
    usually averaging at O(1) due to the efficient hashing mechanism.



# Core Concepts
--- Hash Code: Generated by a hash function, this code helps determine the "bucket" where each element will be stored.
--- Buckets: Containers within the Hash Set used to store elements based on their hash codes.
--- Uniqueness: Hash Sets store only unique elements, meaning duplicates are automatically disregarded.

# Implementation Strategy
--- We'll implement a Hash Set in C, starting with a basic structure and later adding functionality for handling collisions using chaining.

Step 1: Creating the Structure
Define the Hash Set with a fixed number of buckets and basic operations.
    */

          #include <stdio.h>
          #include <stdlib.h>
          #include <string.h>
          
          #define TABLE_SIZE 10
          
          typedef struct Node {
              char *value;
              struct Node *next;
          } Node;
          
          Node* hash_table[TABLE_SIZE]; // Array of Node pointers
          
          // Function prototypes
          unsigned int hash_function(const char *value);
          void add(const char *value);
          int contains(const char *value);
          void remove_element(const char *value);
          void print_set();



// Step 2: Implementing the Hash Function
// The hash function will calculate the hash code by summing Unicode values of characters and taking the modulo with TABLE_SIZE.


        unsigned int hash_function(const char *value) {
            unsigned int hash = 0;
            for (int i = 0; value[i] != '\0'; i++) {
                hash += value[i];
            }
            return hash % TABLE_SIZE;
        }


// Step 3: Adding Elements
// Using the hash function to identify the bucket, we’ll add elements to the Hash Set, while handling collisions by chaining.


        void add(const char *value) {
            unsigned int index = hash_function(value);
            Node *new_node = malloc(sizeof(Node));
            new_node->value = strdup(value);
            new_node->next = NULL;
        
            // If bucket is empty, add directly
            if (hash_table[index] == NULL) {
                hash_table[index] = new_node;
            } else {
                // Check for duplicates and add to the end if unique
                Node *temp = hash_table[index];
                while (temp->next != NULL) {
                    if (strcmp(temp->value, value) == 0) {
                        free(new_node->value);
                        free(new_node);
                        return; // Duplicate found, do nothing
                    }
                    temp = temp->next;
                }
                temp->next = new_node;
            }
        }


// Step 4: Checking for Element Existence
// The contains function quickly checks if an element exists by using the hash code.

        int contains(const char *value) {
            unsigned int index = hash_function(value);
            Node *temp = hash_table[index];
            while (temp != NULL) {
                if (strcmp(temp->value, value) == 0) {
                    return 1; // Element found
                }
                temp = temp->next;
            }
            return 0; // Element not found
        }


// Step 5: Removing Elements
// We can remove elements by navigating to the appropriate bucket and unlinking the targeted element.


        void remove_element(const char *value) {
            unsigned int index = hash_function(value);
            Node *temp = hash_table[index];
            Node *prev = NULL;
        
            while (temp != NULL && strcmp(temp->value, value) != 0) {
                prev = temp;
                temp = temp->next;
            }
        
            if (temp == NULL) return; // Element not found
        
            // Unlink the node
            if (prev == NULL) {
                hash_table[index] = temp->next; // Head element
            } else {
                prev->next = temp->next;
            }
            free(temp->value);
            free(temp);
        }


// Step 6: Printing the Hash Set
// For visualization, we’ll print out all elements in each bucket.


        void print_set() {
            printf("Hash Set Contents:\n");
            for (int i = 0; i < TABLE_SIZE; i++) {
                printf("Bucket %d: ", i);
                Node *temp = hash_table[i];
                while (temp != NULL) {
                    printf("%s -> ", temp->value);
                    temp = temp->next;
                }
                printf("NULL\n");
            }
        }

// Example Usage

        int main() {
            add("Thomas");
            add("Jens");
            add("Peter");
            add("Lisa");
        
            printf("Contains 'Peter': %s\n", contains("Peter") ? "Yes" : "No");
            printf("Contains 'Alice': %s\n", contains("Alice") ? "Yes" : "No");
        
            print_set();
        
            remove_element("Peter");
            printf("Contains 'Peter' after removal: %s\n", contains("Peter") ? "Yes" : "No");
        
            print_set();
        
            return 0;
        }
/*
Expected Output

Contains 'Peter': Yes
Contains 'Alice': No
Hash Set Contents:
Bucket 0: NULL
Bucket 1: Jens -> NULL
Bucket 2: NULL
Bucket 3: NULL
Bucket 4: NULL
Bucket 5: NULL
Bucket 6: NULL
Bucket 7: Lisa -> NULL
Bucket 8: NULL
Bucket 9: Thomas -> Peter -> NULL

Contains 'Peter' after removal: No
Hash Set Contents:
Bucket 0: NULL
Bucket 1: Jens -> NULL
Bucket 2: NULL
Bucket 3: NULL
Bucket 4: NULL
Bucket 5: NULL
Bucket 6: NULL
Bucket 7: Lisa -> NULL
Bucket 8: NULL
Bucket 9: Thomas -> NULL
*/

# Hash Set Summary
--- Hash Code Calculation: Essential for directing elements into the correct bucket, allowing fast operations.
--- Collisions: Managed with chaining, using linked lists within buckets.
--- Time Complexity: Average O(1), but degrades to O(n) in worst-case scenarios, especially if many elements hash to the same bucket.
